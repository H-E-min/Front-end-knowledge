# 线性结构和非线性结构

## 1. 线性结构

`特点`：是数据元素之间存在一对一的线性关系。

`存储结构`：顺序存储、链式存储。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的，链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。

`使用场景`：即队列--先进先出`（FIFO）`和栈--先进后出`（FILO）`。

- 顺序表：计算机中的`顺序存储`是指`在内存中用一块地址连续的空间依次存放数据元素`，`特点`是表中相邻的数据元素在内存中存储位置也相邻。

  顺序表由于`元素连续具有随机存储的特点`，所以`查找`数据很方便`效率很高`，但是`插入、删除`操作为了确保数据元素连续，需要移动大量的数据导致`效率很低`。

  ![img](https://images2015.cnblogs.com/blog/629960/201608/629960-20160809140928262-492338500.png)

- 链表：`链式存储`，只记住第一件物品的位置，寻找的时候从第一件物品开始寻找，通过小纸条我们可以找到所有的物品`（单向链表）`，为了方便找到上一个物品，就有了`双向链表`。

  链表由于存储空间不要求连续，`插入、删除`只需修改相邻元素的引用域地址即可，所以`效率很高`，但`查询`需要从头引用开始遍历链表，`效率很低`。

- 栈

  栈也是一种特殊的线性结构。`栈是一种操作限定在表尾部进行的线性表`，`表尾称为栈顶（Top）`，另一端`固定不动`，称为`栈底`（Bottom）。进栈、出栈示意图如下：

  ![img](https://images2015.cnblogs.com/blog/629960/201608/629960-20160809151153090-1514548602.png)

- 队列

  队列是一种`插入操作限定在表尾其他操作限定在表头`的线性表。把`进行插入操作的表尾称为队尾（Rear)`，把进行`其它操作的头部称为队首（Front）`。入队、出队示意图如下：

  ![img](.\数据结构.assets\629960-20160809152906777-1048463470.png)

## 2.非线性结构

树：树作为一种应用广泛的`一对多非线性数据结构`，不仅有数据间的指向关系，还有层级关系。

- 二叉树

  二叉树是`每个节点最多拥有两个子节点`的树结构，若移除根节点则其余节点会分成两个互不相交的子树，分别称为左子树和右子树。`二叉树是有序树`，左右子树有严格的次序，若颠倒则成为不一样的二叉树。

- 满二叉树

  `除叶子节点外所有节点都拥有两个孩子，且叶子节点在同一层的二叉树。`

- 完全二叉树

  `移除最后一层节点后是满二叉树，且最后一层的节点都连续集中在最左面。`

![img](https://images2015.cnblogs.com/blog/629960/201608/629960-20160812141855625-736751376.png)

### **二叉树存储结构**

1. 顺序存储

   根据完全二叉树的特性，可以计算出任意节点n的双亲节点及左右孩子节点的序号，因此`完全二叉树的节点可以按照从上到下从左到右的顺序依次存储到一维数组中`。`非完全二叉树存储时应先将其改造为完全二叉树，以空替代不存在的节点`，比较浪费存储空间，存储示意图见图四。

2. 链式存储

   类似线性结构链式存储，先`定义数据域和引用的节点，然后通过引用域存储节点之间的关系`。

   ![img](https://images2015.cnblogs.com/blog/629960/201608/629960-20160812161601265-1301764954.png)

### 树与二叉树的转换

 1. **树转二叉树**

    加线，所有兄弟结点之间加一条连线。
    抹线，对树中的每个结点，只保留他与第一个孩子结点之间的连线，删除它与其它孩子结点之间的连线。
    整理，整理前两步得到的树，使之结构层次分明。

    ![img](https://images2015.cnblogs.com/blog/629960/201608/629960-20160812155626000-1300189010.png)

2. **二叉树转树**

   加线，若某结点的左孩子结点存在，将左孩子结点的右孩子结点、右孩子结点的右孩子结点……都作为该结点的孩子结点，将该结点与这些右孩子结点用线连接起来。
   抹线，删除原二叉树中所有结点与其右孩子结点的连线。
   整理，整理前两步得到的树，使之结构层次分明。

   ![img](https://images2015.cnblogs.com/blog/629960/201608/629960-20160812160125515-698914833.png)

   **树的遍历**

   - 先序遍历

     先访问根节点，然后遍历左子树，最后右子树

   - 中序遍历

     先遍历左子树，然后根节点，最后遍历右子树

   - 后序遍历

     先遍历左子树，然后遍历右子树，最后遍历跟节点

   - 层序遍历

     从上向下 从左到右

# 时间复杂度和空间复杂度

时间维度：是指执行当前算法所消耗的时间，用时间复杂度来描述。

空间维度：是指执行当前算法需要占用多少内存空间，用空间复杂度来描述。

## 时间复杂度（**大O符号表示法**）

在 大O符号表示法中，时间复杂度的公式是：` T(n) = O( f(n) )`，其中`f(n) 表示每行代码执行次数之和，而 O 表示正比例关系`，这个公式的全称是：**算法的渐进时间复杂度**。

常见的时间复杂度量级有：

- 常数阶O(1)

  无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：

  ```
  int i = 1;
  int j = 2;
  ++i;
  j++;
  int m = i + j;
  ```

  上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

- 对数阶O(logN)

  ```
  int i = 1;
  while(i<n)
  {
      i = i * 2;
  }
  ```

  从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 n了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n
  也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：**O(logn)**

- 线性阶O(n)

  ```
  for(i=1; i<=n; ++i)
  {
     j = i;
     j++;
  }
  ```

  这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。

- 线性对数阶O(nlogN)

  ```
  for(m=1; m<n; m++)
  {
      i = 1;
      while(i<n)
      {
          i = i * 2;
      }
  }
  ```

  线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。

- 平方阶O(n²)

  平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。

  ```
  for(x=1; i<=n; x++)
  {
     for(i=1; i<=n; i++)
      {
         j = i;
         j++;
      }
  }
  ```

  这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)
  如果将其中一层循环的n改成m，即：

  ```
  for(x=1; i<=m; x++)
  {
     for(i=1; i<=n; i++)
      {
         j = i;
         j++;
      }
  }
  ```

  那它的时间复杂度就变成了 O(m*n)

- 立方阶O(n³)

  参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。

- K次方阶O(n^k)

- 指数阶(2^n)

上面`从上至下依次的时间复杂度越来越大，执行的效率越来越低`。

## 空间复杂度

空间复杂度是`对一个算法在运行过程中临时占用存储空间大小的一个量度`，同样反映的是一个趋势，我们用 S(n) 来定义。

空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看：

1. 空间复杂度O(1)

   如果`算法执行所需要的临时空间不随着某个变量n的大小而变化`，即此算法空间复杂度为一个常量，可表示为 O(1)

   ```
   int i = 1;
   int j = 2;
   ++i;
   j++;
   int m = i + j;
   ```

   代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)

2. **空间复杂度 O(n)**

   ```
   int[] m = new int[n]
   for(i=1; i<=n; ++i)
   {
      j = i;
      j++;
   }
   ```

   这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)



