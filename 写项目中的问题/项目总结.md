## npm安装

1、下载NodeJs（一般选择LTS版本）

> https://nodejs.org/en/

2、安装直接Next即可，安装完成后测试

```shell
node -v
npm -v
```

**3、npm配置**

①、模块路径、cache路径

先配置npm的全局模块的存放路径以及cache的路径，例如希望将以上两个文件夹放在NodeJS的主目录下，便在NodeJs下建立"node_global"及"node_cache"两个文件夹。如下图

![img](https://img-blog.csdn.net/20180729093119324?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEzNDI3MjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



②、使用cmd命令进行配置

```shell
npm config set prefix "H:\nodejs\node_global"
npm config set cache "H:\nodejs\node_cache"
```

如遇**错误**`operation not permitted, mkdir 'C:\Program Files\nodejs'`，使用管理员身份打开cmd命令行即可。

③、测试

```shell
npm install express -g
```

④、配置node_path

- 在`系统变量`中，新建，变量名：`NODE_PATH` 变量值：node_global文件夹下的node_modules文件夹。如：E:\develop\nodejs\node_global\node_modules
- 修改`用户变量`中的`Path`变量，将默认的npm路径修改为新建的node_global路径

## 安装cnpm环境

​	安装淘宝镜像

```shell
npm install -g cnpm --registry=https://registry.npm.taobao.org
```

​	查看是否成功

```shell
cnpm -v
```

​	假如报错，就需要添加系统变量path的内容

## vue-cli的安装

```shell
npm install vue-cli -g （vue-cli2)
npm install -g @vue/cli (vue-cli3）
```

## vue-cli创建项目

​	1、*以下是vue-cli3.x以下的创建webpack的方式*

```shell
vue init webpack 项目名
```

​	![img](https://upload-images.jianshu.io/upload_images/11329965-88a69349b40ee7fe.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

![img](.\项目总结.assets\JdOnline20201230184935.png)

​	2、安装依赖

```shell
cnpm install
```

​	可以安装相应的插件：例如npm install vue-router vue-resource --save等

​	3、运行项目

```shell
cnpm run dev
```

## webpack 创建项目

​	以下是vue-cli3.x的初始化方式，模板是固定的，模板选项可自由配置

```shell
vue create 项目名
```



## router-link

​	可以通过配置 `tag` 属性生成别的标签，默认是a标签，同样也会监听点击事件，触发导航

## element-ui

### el-menu

```
mode：horizontal（水平） | vertical（垂直）
```

​	el-menu渲染在页面中是UL，可以插入Li

​	el-menu-item渲染成Li

### el-table

对slot-scope的使用

```vue
<template>
  <div>
    <el-table :data="fromList" stripe style="width: 100%">
      <el-table-column prop="username" label="姓名" width="180"></el-table-column>
      <el-table-column prop="password" label="密码" width="180"> </el-table-column>
      <el-table-column label="适用性别" align="center">
          //scope只是一个名字，可以随便取
        <template slot-scope="scope">
          <span>{{ scope.row.sex == '0' ? '不限' : scope.row.sex == '1' ? '男' : '女'}}</span>
        </template>
      </el-table-column>
      <el-table-column label="操作" align="center">
        <template slot-scope="scope">
          <el-button type="primary" size="mini" @click="handleUpdate(scope.row)">编辑</el-button>
          <el-button size="mini" type="danger" @click="handleDelete(scope.row)">删除</el-button>
        </template>
        <template slot-scope="scope">
          {{scope.row}}
        </template>
      </el-table-column>
    </el-table>
  </div>
</template>
```

`scope.row`的输出结果：

![image-20210104181051994](.\项目总结.assets\image-20210104181051994.png)

​	table里的标签使用

```vue
<el-tag v-if="scope.row.state === '已完成'" :type="'success'"
	disable-transitions>{{scope.row.state}}
</el-tag>
<el-tag v-else-if="scope.row.state === '未开始'" :type="'danger'"
	disable-transitions>{{scope.row.state}}
</el-tag>
<el-tag v-else-if="scope.row.state === '进行中'" :type="'warning'"
	disable-transitions>{{scope.row.state}}
</el-tag>
```

## 公共组件的使用

​	在公共组件中的且可能在不同页面展示不同内容的需要用props来定义，在父组件中通过属性绑定来实现传值

```js
//公共组件
<li class="header-name el-menu-item">
    <a href="/home">{{ title }}</a>
</li>

<script>
  	export default {
     props: {
        title: String,
      },
    }
</script>
```

```js
//父组件中
<div class="app_header">
      <common-header title="运营平台"></common-header>
</div>

<script>
	import commonHeader from "commons/common-header";
	export default {
        components: {
            commonHeader
        },
	}
</script>
```

## Object.assign (浅拷贝)

​	用于对象的合并，将`源对象`的所有可枚举属性`复制到目标对象`

```js
Object.assign(target, source1, source2);
```

## window.location.

​	用该属性获取页面 URL 地址；

​	window.location 对象所包含的属性：

```
属性		   描述
hash		从井号 (#) 开始的 URL（锚）
host		主机名和当前 URL 的端口号
hostname	当前 URL 的主机名
href		完整的 URL
pathname	当前 URL 的路径部分
port		当前 URL 的端口号
protocol	当前 URL 的协议
search		从问号 (?) 开始的 URL（查询部分）
```

## split

​	split() 方法用于把一个`字符串`分割成`字符串数组`。

```
stringObject.split(separator,howmany)
//separator:必需，可以是字符串或正则表达式
//howmany:该参数返回数组的最大长度，设置了该参数，返回的子串不会多于这个参数指定的数组
```

Eg：

```js
<script type="text/javascript">
var str="How are you doing today?"
document.write(str.split(" ") + "<br />")
document.write(str.split("") + "<br />")
document.write(str.split(" ",3))
</script>
```

## decodeURI

​	`	decodeURI() `函数可对 encodeURI() 函数编码过的 URI 进行`解码`。

## **JSON.stringify()**

​	将` JavaScript 对象`转换为`字符串`

## JSON.parse()

​	将一个` JSON 字符串`转换为`对象`

## process.env.NODE_ENV

​	NODE_ENV不是process.env对象上原有的属性，它是我们自己添加上去的一个环境变量，用来确定当前所处的开发阶段。一般`生产阶段`设为`production`，`开发阶段`设为`develop`，然后在脚本中读取process.env.NODE_ENV。

## State、mapState、...mapState

​	**state**在使用的时候一般被挂载到`computed`计算属性上，`有利于state的值发生改变的时候及时响应给子组件`

​	**mapState**是state的辅助函数，实际作用：当一个组件需要获取多个状态时，将这些状态都声明为计算属性会有些重复和冗余，为了解决这个问题。使用mapState辅助函数生成计算属性，可以少按几次键（简单的说就是在computed中既要计算属性又要用到vuex中的值时，可以考虑用mapState）

​	**第一步：使用前导入**

```js
import { mapState } from 'vuex'
```

​	**第二步：使用**

```js
computed: mapState({
    count: 'count', // 第一种写法
    sex: (state) => state.sex, // 第二种写法
    from: function (state) { // 用普通函数this指向vue实例,要注意
      return this.str + ':' + state.from
    },
    // 注意下面的写法看起来和上面相同,事实上箭头函数的this指针并没有指向vue实例,因此不要滥用箭头函数
    // from: (state) => this.str + ':' + state.from
  })
**在用到state的同时还需要借助当前vue实例的this,务必写常规写法**
```

```js
//之前的computed
computed:{
    fn1(){ return ...},
    fn2(){ return ...},
    fn3(){ return ...}
    ........
}
//引入mapState辅助函数之后
 
computed:mapState({
    //先复制粘贴
    fn1(){ return ...},
    fn2(){ return ...},
    fn3(){ return ...}
    ......
    //再维护vuex
    count:'count'
    .......
})
```

**...mapState**是...对象展开符的扩展

```js
  computed: { ...mapState(["currentUser"]) },
```

```js
//之前的computed
computed:{
    fn1(){ return ...},
    fn2(){ return ...},
    fn3(){ return ...}
    ........
}
//引入mapState辅助函数之后
 
computed:{
    //原来的继续保留
    fn1(){ return ...},
    fn2(){ return ...},
    fn3(){ return ...}
    ......
    //再维护vuex
    ...mapState({  //这里的...不是省略号了,是对象扩展符
        count:'count'
    })
}
//使用...mapState后，在页面中可以直接使用this.属性名调用即可，省去了this.$store.state.属性名
```

## git操作

> 1.查看远程仓库
> git remote -v
> 2.从远程获取最新版本到本地
> git pull origin master
> git pull
>
> 3.查看状态
>
> git status

**从远程仓库下载的文件上传时**

```shell
git add .
git commit -m "注释"
git pull
git push
```

![img](.\项目总结.assets\JdOnline20201230164418.png)



## 导出后台提供的文件

window.location.href=`地址以及后台需要的参数`

## git全局配置

**查看**

```shell
git config --list
```

**新增**

```shell
//配置用户名
git config --global user.name "hm"
//配置用户邮箱
git config --global user.email "111@163.com"
```

## scss在Vue中的安装及使用

​	**安装**

```shell
npm install node-sass --save-dev //安装node-sass 
npm install sass-loader --save-dev //安装sass-loader 
npm install style-loader --save-dev //安装style-loader 有些人安装的是 vue-style-loader 其实是一样的！
```

​	**配置文件**

​	在webpack.base.conf.js 文件下的配置 rules

```js
rules:[
...
{ //从这一段上面是默认的！不用改！下面是没有的需要你手动添加，相当于是编译识别scss!
    test: /\.scss?$/,
    loaders: ["style", "css", "sass"]
}
]
```

​	**在vue模板组件中引用 lange="scss"**

```js
<style lang="scss" scoped>
	...
</style>
```

## JS正则匹配截取数字

```js
var reg = /[1-9][0-9]*/g;
var reward = ‘adad13dd1’
console.log(reward.match(reg)[0])		//131
```

## 封装组件——父子组件传值

父组件向子组件传值

​	在父组件上`绑定属性`(v-bind)，然后在子组件中通过`props:['父组件的属性名']`接受参数

```vue
//父组件
<template>
	<div>
        <input type="text" v-model="InputValue"/><button @click="handleClick">添加</button>
        <ul>
          <li-com  v-for="(item,index) in list" :key="index" :content='item'></li-com>
        </ul>
    </div>
</template>

<script>
	import LiCom from '@/components/liCom.vue'
	export default {
        components: {
            LiCom
        },
        data(){
        	InputValue:'',
      		list:[]
        },
        methods:{
        	handleClick(){
              this.list.push(this.InputValue)
              this.InputValue = ''
              console.log(this.list)
            }
        }
	}
</script>
```

```vue
//子组件
<template>
  <div class="Lis">
     <li>{{content}}</li>
  </div>
</template>

<script>
export default {
  name:'LiCom',
  props:{
    content:''
  }
}
</script>
```

子组件向父组件传值

​	通过自定义事件，子组件执行的函数名{  this.$emit('父组件的自定义方法名') ,参数(可有可无)}——子组件触发事件，父组件恰好在监听。

```vue
//父组件
<template>
	<div>
        <input type="text" v-model="InputValue"/><button @click="handleClick">添加</button>
        <ul>
          <li-com  v-for="(item,index) in list" :key="index" :content='item' @delete="handleDel"></li-com>
        </ul>
    </div>
</template>

<script>
	import LiCom from '@/components/liCom.vue'
	export default {
        components: {
            LiCom
        },
        data(){
        	InputValue:'',
      		list:[]
        },
        methods:{
        	handleClick(){
              this.list.push(this.InputValue)
              this.InputValue = ''
            },
            handleDel(index){
              this.list.splice(index,1)
            }
        }
	}
</script>
```

```vue
//子组件
<template>
  <div class="Lis">
     <li @click="handleClick">{{content}}</li>
  </div>
</template>

<script>
export default {
  name:'LiCom',
  props:{
    content:'',
    index:''
  },
  methods:{
    handleClick(){
      this.$emit('delete',this.index)
    }
  }
}
</script>
```



## ref和$ref

​	ref：用来给元素或子组件注册引用信息。

​	$refs：Object，持有已注册过`ref`的所有子组件，是一个集合。

![image-20210107155934859](.\项目总结.assets\image-20210107155934859.png)

​	当`ref`和`v-for`一起使用时，获取到的引用会是一个数组，包含和循环数据源对应的子组件。

​	`$refs`只在`组件渲染完成后才填充`，并且它是`非响应式的`，它仅仅是`直接操作子组件的应急方案`——避免在模板或计算属性中使用。

### 用法

	#### 一、常规用法

1. **当ref用在组件上时，通过$refs获取的是该组件的实例，可进而调用组件内定义的方法、属性等；**

   如下所示，当ref定义在组件Home上时，通过this.$refs.test获取的是Home组件对应的实例对象，通常我们可以通过这种方式来调用某个组件内的methods、data中定义的数据、或是进而获取其子组件等。

   ```vue
   <template>
     <div id="app">
       <Home ref="test" />
     </div>
   </template>
   
   <script>
   import Home from './views/Home'
   export default {
     components: { Home },
     mounted () {
       console.log(this.$refs.test)
     }
   }
   </script>
   ```

2. 　**当ref用在DOM节点上时，通过$refs获取的是该DOM元素节点。**

   如下图所示，当ref定义在DOM元素上时，通过this.$refs.test获取的是该DOM元素，且包含子元素，进而可以进行下一步的DOM操作。

   ![image-20210107172535916](.\项目总结.assets\image-20210107172535916.png)

#### **二、多处ref引用的值相同时（非v-for内使用时）**

1. 　**当html中ref值相同的节点是兄弟节点时，通过$refs获取到的是文档中顺序靠下的节点（使用在DOM上和组件上原则一致，以DOM为例）**

   ![image-20210107172655903](.\项目总结.assets\image-20210107172655903.png)

2. **当html中ref值相同的节点是嵌套关系时，比如父子关系，则通过$refs获取到的是外层节点\**（使用在DOM上和组件上原则一致，以DOM为例）\****

   ![image-20210107172750906](.\项目总结.assets\image-20210107172750906.png)

3. **当html中ref值相同的节点不在同一层级，也不是嵌套关系时，仍然遵循文档中顺序靠下的节点被获取的原则（使用在DOM上和组件上原则一致，以DOM为例）**

   ![image-20210107172825863](.\项目总结.assets\image-20210107172825863.png)

####  三、当ref值是个变量时（**非v-for内使用时**）

1. **ref值使用变量时，通过this.$refs[变量名称]指向的依旧是该DOM节点或组件实例，不需要加[0]，且当出现ref值重复时，仍然满足上面的原则**

   ![image-20210107173025968](.\项目总结.assets\image-20210107173025968.png)

#### 四、ref用在v-for上时

1. ​	**当ref值相同时，this.$refs[ref名称]获取到的是该DOM节点或组件的数组，此处以组件为例**

   ![image-20210107173513893](.\项目总结.assets\image-20210107173513893.png)

2. **当ref值不同时，this.$refs[ref名称]无法获取对应的DOM节点或是组件，需要在其后追加[0]才可访问，此处以组件为例**

![image-20210107173630038](.\项目总结.assets\image-20210107173630038.png)

#### 五、总结

　　　　 1. ref用在DOM上时，通过this.$refs[ref名称]访问的是该DOM元素节点；ref用在组件上时，通过this.$refs[ref名称]访问的是该组件的实例对象，可以进而调用组件的方法或者获取组件的属性等；

　　　　2. 当同一组件内部，有多处ref引用值相同的情况时，this.$refs[ref名称]指向文档流中靠下的组件或DOM节点，若是父子关系，则指向父级组件或DOM节点；

　　　　3. 若ref的值是个变量，只要不是用在v-for里，通过this.$refs[变量名称]指向的依旧是该DOM节点或组件实例，且当出现ref值重复时，仍然满足取靠下的节点或是父级节点的规则；

　　　　4. 若ref用在v-for里，当循环内的ref值相同时，this.$refs[ref名称]获取到的是该DOM节点或组件的数组，当ref值不同时，需提供this.$refs[ref名称][0]来获取该DOM节点或组件实例。







